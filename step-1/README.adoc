= A minimally viable wiki written with Vert.x

We are going to start with a first iteration with the simplest code possible to have a wiki written with Vert.x.
While the next iterations will introduce more elegance into the code base as well as proper testing, we will see that quick prototyping with Vert.x is both a simple and a realistic target.

At this stage the wiki will use server-side rendering of HTML pages and data persistence through a JDBC connection.
To do so, we will use the following libraries.

1. http://vertx.io/docs/vertx-web/java/[Vert.x web] since while the Vert.x core library _does_ support the creation of HTTP servers, it does not provide elegant APIs to deal with routing, handling of request payloads, etc.
2. http://vertx.io/docs/vertx-jdbc-client/java/[Vert.x JDBC client] to provide an asynchronous API over JDBC.
3. http://freemarker.org/[Apache FreeMarker] to render server-side pages as it is an uncomplicated templating engine.
4. https://github.com/rjeschke/txtmark[Txtmark] to render Markdown text to HTML, allowing the edition of wiki pages in Markdown.

== Bootstrapping a Maven project

This guide makes the choice of using https://maven.apache.org[Apache Maven] as the build tool, primarily because it is very well integrated with the major integrated development environments.
You can equally use another build tool such as https://gradle.org/[Gradle].

The Vert.x community offers a template project structure from https://github.com/vert-x3/vertx-maven-starter that can be cloned.
Since you will likely want to use (Git) version control as well, the fastest route is to clone the repository, delete its `.git/` folder and then create a new Git repository:

    git clone https://github.com/vert-x3/vertx-maven-starter.git vertx-wiki
    cd vertx-wiki
    rm -rf .git
    git init

The project offers a sample verticle as well as a unit test.
You can safely delete all `.java` files beneath `src/` to hack on the wiki, but before doing so you may test that the project builds and runs successfully:

    mvn package exec:java

You will notice that the Maven project `pom.xml` does 2 interesting things:

1. it uses the https://maven.apache.org/plugins/maven-shade-plugin/[Maven Shade Plugin] to create a single Jar archive with all required dependencies, suffixed by `-fat.jar`, also called _"a fat Jar"_, and
2. it uses the http://www.mojohaus.org/exec-maven-plugin/[Exec Maven Plugin] to provide the `exec:java` goal that in turns starts the application through the Vert.x `io.vertx.core.Launcher` class. This is actually equivalent to running using the `vertx` command-line tool that ships in the Vert.x distribution.

Finally, you will notice the presence of the `redeploy.sh` and `redeploy.bat` scripts that you can alternatively use for automatic compilation and redeployment upon code changes.
Note that doing requires ensuring that the `VERTICLE` variable in these scripts matches the main verticle to be used.

== Adding the required dependencies

The first batch of dependencies to add to the Maven `pom.xml` file are those for the web processing and rendering:

[source,xml,indent=0]
----
include::pom.xml[tags=web-deps]
----

TIP: As the `vertx-web-templ-freemarker` name suggests, Vert.x web provides pluggable support for popular templating engines: Handlebars, Jade, MVEL, Pebble, Thymeleaf and of course Freemarker.

The second set of dependencies are those required for JDBC database access:

[source,xml,indent=0]
----
include::pom.xml[tags=db-deps]
----

The Vert.x JDBC client library provides access to any JDBC-compliant database, but of course our project needs to have a JDBC driver on the _classpath_.

http://hsqldb.org/[HSQLDB] is well-known relationnal database that is written in Java.
It is quite popular when used as an embedded database to avoid the requirement of having a third-party database server running separately.
It is also popular for unit and integration testing as it offers a (volatile) in-memory storage.

HSQLDB as an embedded database is a good fit to get us started.
It stores data in local files, and since the HSQLDB library Jar provides a JDBC driver the Vert.x JDBC configuration will be straightforward.

[NOTE]
====
Vert.x also offers a dedicated http://vertx.io/docs/vertx-mysql-postgresql-client/java/[MySQL and PostgreSQL client] library.

Of course you can use the general-purpose Vert.x JDBC client to connect to MySQL or PostgreSQL databases, but this library offers better performance and asynchronous support by working with these 2 database server network protocols rather than going through the blocking JDBC APIs.
====

NOTE: Vert.x also provides libraries to deal with the popular non-relational databases http://vertx.io/docs/vertx-mongo-client/java/[MongoDB] and http://vertx.io/docs/vertx-redis-client/java/[Redis].

== Anatomy of a verticle

The verticle for our wiki consists of a single `io.vertx.guides.wiki.MainVerticle` Java class.
This class extends `io.vertx.core.AbstractVerticle`, the base class for verticles that mainly provides:

1. life-cycle `start` and `stop` methods to eventually override, and
2. a _protected_ field called `vertx` that references the Vert.x environment where the verticle is being deployed, and
3. an accessor to some configuration object that allows passing external configuration to a verticle.

To get started our verticle can just override the `start` method as follows:

[source,java]
----
public class MainVerticle extends AbstractVerticle {

  @Override
  public void start(Future<Void> startFuture) throws Exception {
    startFuture.complete();
  }
}
----

There are 2 forms of `start` (and `stop`) methods: 1 with no argument and 1 with a _future_ object reference.
The no-argument variants imply that the verticle initialization or house-keeping phases always succeed unless an exception is being thrown.
The variants with a _future_ object provide a more fine-grained approach to _eventually_ signal that operations succeeded or not.
Indeed, some initialization or cleanup code may require asynchronous operations, so reporting via a _future_ object naturally fits with asynchronous idioms.

== Wiki verticle initialization phases

To get our wiki running, we need to perform a 2-phases initialization:

1. we need to establish a JDBC database connection, and also make sure that the database schema is in place, and
2. we need to start a HTTP server for the web application.

Each phase can fail (e.g., the HTTP server TCP port is already being used), and they should not run in parallel as the web application code first needs the database access to work.

To make our code _cleaner_ we will define 1 method per phase, and adopt a pattern of returning a _future_ object to notify when each phases completes, and whether it did so successfully or not:

[source,java]
----
private Future<Void> prepareDatabase() {
  Future<Void> future = Future.future();
  // (...)
  return future;
}

private Future<Void> startHttpServer() {
  Future<Void> future = Future.future();
  // (...)
  return future;
}
----

By having each method returning a _future_ object, the implementation of the `start` method becomes a composition:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=start]
----

When the _future_ of `prepareDatabase` completes successfully, then `startHttpServer` is called and the `steps` future completes depending of the outcome of the future returned by `startHttpServer`.
`startHttpServer` is never called if `prepareDatabase` encounters an error, in which case the `steps` _future_ is in a _failed_ state and has been completed with the exception describing the error.

Eventually `steps` completes: `setHandler` defines a handler to be called upon completion.
In our case we simply want to complete `startFuture` with `steps` and use the `completer` method to obtain a handler.
This is equivalent to:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=another-start]
----

=== Database initialization

The wiki database schema consists of a single table `Pages` with the following columns:

[options="header"]
|===
|Column |Type |Description

|`Id`
|Integer
|Primary key

|`Name`
|Characters
|Name of a wiki page, must be unique

|`Content`
|Text
|Markdown text of a wiki page
|===

The database operations will be typical _create, read, update, delete_ operations.
To get us started, we simply store the corresponding SQL queries as static fields of the `MainVerticle` class.
Note that they are written in a dialect that HSQLDB understands, but that other relational databases may not necessarily support:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=sql-fields]
----
<1> The `?` in the queries are placeholders to pass data when executing queries, and the Vert.x JDBC client prevents from SQL injections.

The application verticle needs to keep a reference to a `JDBCClient` object (from the `io.vertx.ext.jdbc` package) that serves as the connection to the database.
We do so using a field in `MainVerticle`, and we also create a general-purpose logger from the `io.vertx.core.logging` package:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=db-and-logger]
----

Last but not least, here is the complete implementation of the `prepareDatabase` method.
It attempts to obtain a JDBC client connection, then performs a SQL query to create the `Pages` table unless it already exists:

[source,java,indent=0]
----
include::src/main/java/io/vertx/guides/wiki/MainVerticle.java[tags=prepareDatabase]
----
<1> `createShared` creates a shared connection to be shared among verticles known to the `vertx` instance, which in general is a good thing.
<2> The JDBC client connection is made by passing a Vert.x JSON object. Here `url` is the JDBC URL.
<3> Just like `url`, `driver_class` is specific to the JDBC driver being used and points to the driver class.
<4> `max_pool_size` is the number of concurrent connections. We chose 30 here, but it is just an arbitrary number.
<5> Getting a connection is an asynchronous operation that gives us an `AsyncResult<SQLConnection>`. It must then be tested to see if the connection could be established or not (`AsyncResult` is actually a super-interface of `Future`).
<6> If the SQL connection could not be obtained, then the method _future_ is completed to fail with the `AsyncResult`-provided exception via the `cause` method.
<7> The `SQLConnection` is the result of the successful `AsyncResult`. We can use it to perform a SQL query.
<8> Before checking whether the SQL query succeeded or not, we must release it by calling `close`, otherwise the JDBC client connection pool can eventually drain.
<9> We complete the method _future_ object with a success.
